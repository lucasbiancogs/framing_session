---
description: Global rules for the Supabase Realtime learning project
globs: "*"
alwaysApply: true
---

# Framing Session — Global Context

## Project Purpose

This is a **learning project** for building a collaborative whiteboard application using:

- **Flutter** — Mobile/web client
- **Supabase Realtime** — Backend realtime infrastructure

The goal is to deeply understand Supabase's three realtime tools by building one feature at a time.

---

## The Whiteboard Domain

We're modeling a collaborative whiteboard where multiple users can:

- Create and edit shapes (rectangles, circles, lines)
- See each other's cursors moving in real-time
- Know who else is currently viewing the board

---

## How Everything Is Modeled

### The Three Realtime Tools

| Tool                        | What It Does                  | Persistence              | Source of Truth     |
|-----------------------------|-------------------------------|--------------------------|---------------------|
| **Database Realtime (CDC)** | Streams database changes      | Permanent (Postgres)     | The database        |
| **Presence**                | Tracks connected users        | Ephemeral (memory only)  | Channel state       |
| **Broadcast**               | Fire-and-forget messages      | None                     | None                |

### Feature-to-Tool Mapping

| Whiteboard Feature       | Realtime Tool  | Why This Tool                                      |
|--------------------------|----------------|----------------------------------------------------|
| **Shape creation**       | Database CDC   | Shapes must persist — refresh should show them     |
| **Shape property edits** | Database CDC   | Changes must be permanent and queryable            |
| **Session metadata**     | Database CDC   | Session info survives reconnection                 |
| **User list (online)**   | Presence       | Only care about who's connected NOW                |
| **User colors/names**    | Presence       | Tied to connection lifetime, auto-cleanup          |
| **Cursor movement**      | Broadcast      | 30-60 updates/sec, missing one is fine             |
| **Drawing in progress**  | Broadcast      | Transient visual feedback, no persistence needed   |

### The Critical Question

> **"What happens if a client reconnects after missing updates?"**

| Tool             | Answer                                           |
|------------------|--------------------------------------------------|
| **Database CDC** | Client queries the database — all data is there  |
| **Presence**     | Client receives `sync` event with current state  |
| **Broadcast**    | Client missed the messages — they're gone        |

---

## Repository Structure

```
/
├── README.md
├── PHASES.md              ← Progress tracking only
│
├── .cursor/rules/         ← This folder
│   ├── global.mdc         ← Always active
│   ├── architecture.mdc   ← DDD architecture patterns
│   ├── phase-*.mdc        ← Phase-specific rules
│   └── *.mdc              ← Other pattern rules
│
├── supabase/
│   ├── README.md
│   ├── schema/            ← SQL table definitions
│   │   ├── sessions.sql
│   │   ├── shapes.sql
│   │   └── shape_type.sql
│   ├── realtime/          ← Realtime documentation
│   │   ├── presence.md
│   │   └── broadcast.md
│   └── notes/
│       └── concepts.md    ← Core mental model
│
└── flutter/
    ├── README.md
    ├── pubspec.yaml
    └── lib/
        ├── main.dart
        ├── app/               ← App configuration, Supabase setup
        │   └── supabase_config.dart
        ├── core/              ← Cross-cutting concerns
        │   ├── errors/        ← Base exceptions
        │   └── config/        ← Environment config
        ├── domain/            ← Business logic layer
        │   ├── entities/      ← Session, Shape
        │   └── services/      ← Interface + implementation
        ├── data/              ← Data layer
        │   ├── dtos/          ← Data transfer objects
        │   └── datasources/   ← Supabase data sources
        └── presentation/      ← UI layer
            ├── pages/         ← Feature pages
            ├── widgets/       ← Reusable widgets
            └── view_models/   ← Global providers
```

---

## Global Rules

### 1. Phases Are Isolated

Each phase is self-contained. Do not assume previous phases were completed.
Every phase must restate:
- Goal
- Concepts
- Assumptions

### 2. No Automatic Progression

The next phase only begins when I explicitly prompt it.
Never suggest moving to the next phase.

### 3. README-First

Every phase produces:
- A README section or documentation update
- A checklist of TODOs for me to complete

### 4. TODOs in PHASES.md

At the end of each phase prompt, **always** add a checklist section to `PHASES.md`:

```markdown
## Phase N — Phase Name

- [ ] First task
- [ ] Second task
- [ ] Third task
```

This is the single source of truth for tracking progress.

### 5. Example, Not Completion

Provide ONE correct pattern per phase.
I finish the rest myself.

### 6. Folder Separation Is Mandatory

- **Flutter ≠ Supabase**
- Backend concepts must NEVER be buried in UI code
- Follow the DDD layer structure (see architecture.mdc)
- Supabase configuration and concepts stay in `supabase/`

### 7. No Over-Engineering

- Only implement what the current phase requires
- No "while we're here" additions
- No premature abstractions

### 8. Architecture Patterns (When Building Features)

When building Flutter features, follow the patterns in `.cursor/rules/architecture.mdc`:
- **Entities** in `domain/entities/` — immutable, extend Equatable
- **Services** in `domain/services/` — interface + implementation in same file
- **DTOs** in `data/dtos/` — with fromMap, toMap, toEntity, fromEntity
- **DataSources** in `data/datasources/` — return DTOs, not entities
- **ViewModels** in `presentation/pages/[feature]/` — StateNotifier pattern
- **Pages** in `presentation/pages/[feature]/` — ConsumerWidget

---

## Common Mistakes to Avoid

### Using Database for High-Frequency Updates

```
❌ INSERT INTO cursor_positions (user_id, x, y) VALUES (...)
```

Cursors update 30-60 times/second. Database will choke.
Use **Broadcast** instead.

### Using Broadcast for Persistent Data

```
❌ channel.send({ type: 'shape_created', shape: {...} })
```

If a client joins late, they never see the shape.
Use **Database CDC** instead.

### Using Database for "Who's Online"

```
❌ UPDATE users SET is_online = true WHERE id = ...
```

Complex, unreliable, doesn't handle crashes.
Use **Presence** instead — automatic cleanup on disconnect.

### Direct Database Access in UI

```dart
// ❌ Never do this in a widget
final response = await Supabase.instance.client.from('shapes').select();
```

Always go through Services → DataSources. See architecture.mdc.

---

## How to Use Phase Rules

When starting a new phase:

1. Tell the assistant: "I'm starting Phase N"
2. Or reference the rule: "Apply phase-N rules"

Phase rules are in `.cursor/rules/phase-*.mdc`

---

## Related Rules

- [architecture.mdc](./architecture.mdc) — DDD layer structure and patterns
- [dto-entities.mdc](./dto-entities.mdc) — Data transformation patterns
- [state-management.mdc](./state-management.mdc) — Riverpod and StateNotifier
- [view-models.mdc](./view-models.mdc) — ViewModel implementation
- [ui-components.mdc](./ui-components.mdc) — Widget patterns
- [flutter-best-practices.mdc](./flutter-best-practices.mdc) — Flutter conventions
